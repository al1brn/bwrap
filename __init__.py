#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Jan 26 21:41:34 2021@author: alain"""bl_info = {    "name":     "Blender wrap",    "author":   "Alain Bernard",    "version":  (1, 0),    "blender":  (2, 80, 0),    "location": "View3D > Sidebar > Wrap",    "description": "Wrapanime commands and custom parameters",    "warning":   "",    "wiki_url":  "",    "category":  "3D View"}import bpyfrom .core.wrappers import wrapfrom .core.blender import create_collectionfrom .core.blender import get_collectionfrom .core.blender import get_object_collectionsfrom .core.blender import put_object_in_collectionfrom .core.blender import wrap_collectionfrom .core.blender import control_collectionfrom .core.blender import get_framefrom .core.blender import create_objectfrom .core.blender import get_objectfrom .core.blender import get_create_objectfrom .core.blender import get_control_objectfrom .core.blender import copy_modifiersfrom .core.blender import delete_objectfrom .core.blender import smooth_objectfrom .core.blender import hide_objectfrom .core.blender import show_objectfrom .core.blender import set_materialfrom .core.duplicator import Duplicatorfrom .core.commons import base_error_titleerror_title = base_error_title % "main.%s"  # ******************************************************************************************************************************************************# Animation classclass Animation():        def __init__(self):        self.update_ready = False        def setup(self):        self.update_ready = False        def setup_update(self):        pass        def update(self, frame):        pass        def run_update(self, frame):        if not self.update_ready:            self.setup_update()            self.update_ready = True                    self.update(frame)                # ******************************************************************************************************************************************************# ******************************************************************************************************************************************************# Kernel handler# ******************************************************************************************************************************************************# ******************************************************************************************************************************************************def cur_frame():    return bpy.context.scene.frame_current_finaldef cur_time():    return bpy.context.scene.frame_current_final / bpy.context.scene.render.fpsdef frame_from_time(time):    return time * bpy.context.scene.render.fpsdef time_from_frame(frame):    frame / bpy.context.scene.render.fpsclass Interval():    def __init__(self, start=None, end=None):        self.start = start        self.end   = end            def __repr__(self):        return f"[{self.start}, {self.end}["                    def when(self, frame):        if self.start is not None:            if frame < get_frame(self.start):                return -1                if self.end is not None:            if frame >= get_frame(self.end):                return 1                    return 0        class Animator():        def __init__(self, interval, action_before=None, action_during=None, action_after=None):                self.interval      = interval                self.action_before = action_before        self.action_during = action_during        self.action_after  = action_after                self.objects       = []            @classmethod    def Hider(Cls, objects, after=None, before=None):        hider = Cls(Interval(after, before))        hider.objects = objects        hider.action_before = hider.show        hider.action_during = hider.hide        hider.action_after  = hider.show        return hider            @classmethod    def Shower(Cls, objects, after=None, before=None):        shower = Cls(Interval(after, before))        shower.objects = objects        shower.action_before = shower.hide        shower.action_during = shower.show        shower.action_after  = shower.hide        return shower            def execute(self, frame):                when = self.interval.when(frame)        if when == -1:            if self.action_before is not None:                self.action_before(frame)                        elif when == 0:            if self.action_during is not None:                self.action_during(frame)                        else:            if self.action_after is not None:                self.action_after(frame)                    def hide(self, frame):        for obj in self.objects:            obj.hide_render   = True            obj.hide_viewport = bpy.context.scene.wa_hide_viewport            def show(self, frame):        for obj in self.objects:            obj.hide_render   = False            obj.hide_viewport = Falseclass FunctionAnimator(Animator):        def __init__(self, f, after=None, before=None):                super().__init__(Interval(after, before), None, self.run_f)        self.f = f            def run_f(self, frame):        if Engine.verbose:            print(f"   Run function '{self.f.__name__}' in interval {self.interval}")        self.f(frame)                class Engine():    SETUP      = [] # Setup functions    FUNCTIONS  = [] # Update functions    ANIMATIONS = [] # Animations        #frame_exec    = False    verbose       = False    #hide_viewport = True     # For hiding / showing objects        #@staticmethod    #@property    #def frame_exec():    #    return bpy.context.scene.wa_frame_exec        @staticmethod    def clear():        Engine.FUNCTIONS = []        Engine.SETUP     = []        Engine.ANIMATIONS = []            @staticmethod    def register_animation(animation):        Engine.ANIMATIONS.append(animation)        #animation.setup()            @staticmethod    def register_setup(f):        Engine.SETUP.append(f)            @staticmethod    def setup():        print("Engine.setup...")        for animation in Engine.ANIMATIONS:            animation.setup()            animation.update_ready = False        print("Engine.setup done!")        for f in Engine.SETUP:            f()            @staticmethod    def register(f, after=None, before=None):        Engine.FUNCTIONS.append(FunctionAnimator(f, after, before))            @staticmethod    def show_objects(objects, after=None, before=None):        Engine.FUNCTIONS.append(Animator.Shower(objects, after, before))            @staticmethod    def hide_objects(objects, after=None, before=None):        Engine.FUNCTIONS.append(Animator.Hider(objects, after, before))            @staticmethod    def execute():        frame = cur_frame()                if Engine.verbose:            print(f"Engine exec, frame {frame:6.1f} in interval [self.interval]")                    for animation in Engine.ANIMATIONS:            animation.run_update(frame)            for anm in Engine.FUNCTIONS:            anm.execute(frame)    @staticmethod    def run(go=True):        bpy.context.scene.wa_frame_exec = go        if go:            Engine.execute()            def engine_handler(scene):    if  bpy.context.scene.wa_frame_exec:        Engine.execute()        # ==========================================================================================# UIclass ClearParamsOperator(bpy.types.Operator):    """Delete the user parameters"""    bl_idname = "wrap.clear_params"    bl_label = "Clear parameters"    @classmethod    def poll(cls, context):        return True    def execute(self, context):        del_params()        return {'FINISHED'}class SetupOperator(bpy.types.Operator):    """Execute the initial set up functions"""    bl_idname = "wrap.setup"    bl_label = "Setup"    @classmethod    def poll(cls, context):        return True    def execute(self, context):        Engine.setup()        return {'FINISHED'}class ExecOperator(bpy.types.Operator):    """Execute the udate function"""    bl_idname = "wrap.exec"    bl_label = "Update"    @classmethod    def poll(cls, context):        return True    def execute(self, context):        Engine.execute()        return {'FINISHED'}def ui_param_full_name(name, group):    return f"{group}.{name}"def ui_param_list(ctl):        params = {}    def add(group, name, key):        ps = params.get(group)        if ps is None:            params[group] = [(name, key)]        else:            ps.append((name, key))                for key in ctl.keys():        if key[0] != "_":            gn = key.split('.')            if len(gn) == 1:                add("_main", key, key)            else:                add("_main" if gn[0] == "" else gn[0], gn[1], key)                    return paramsdef scalar_param(name, default=0., min=0., max=1., group="", description="Wrapanime parameter"):        ctl = get_control_object()    rna = ctl['_RNA_UI']        fname = ui_param_full_name(name, group)    prm   = ctl.get(fname)    if prm is None:        ctl[fname] = default            rna[fname] = {        "description": description,        "default":     default,        "min":         min,        "max":         max,        "soft_min":    min,        "soft_max":    max,        }def bool_param(name, default=True, group="", description="Wrapanime parameter"):        ctl = get_control_object()    rna = ctl['_RNA_UI']        fname = ui_param_full_name(name, group)    prm   = ctl.get(fname)    if prm is None:        ctl[fname] = default            rna[fname] = {        "description": description,        "default":     default,        }def vector_param(name, default=(0., 0., 0.), group="", description="Wrapanime parameter"):        ctl = get_control_object()    rna = ctl['_RNA_UI']        fname = ui_param_full_name(name, group)    prm   = ctl.get(fname)    if prm is None:        ctl[fname] = default            rna[fname] = {        "description": description,        "default":     default,        }    def get_param(name, group=""):    ctl = get_control_object()    val = ctl.get(ui_param_full_name(name, group))    if val is None:        print(f"Wrapanime WARNING: param {name} doesn't exist.")    return valdef del_params():    ctl = get_control_object()    keys = ctl.keys()    for k in keys:        del ctl[k]    class WAMainPanel(bpy.types.Panel):    """Wrapanime commands"""    bl_label        = "Commands"    bl_category     = "Wrap"    #bl_idname       = "SCENE_PT_layout"    bl_space_type   = 'VIEW_3D'    bl_region_type  = 'UI'    #bl_context      = "scene"    def draw(self, context):        layout = self.layout        scene = context.scene                layout.operator("wrap.setup", icon='FACE_MAPS')        layout.operator("wrap.exec", icon='FILE_REFRESH')        if context.screen.is_animation_playing:            layout.operator("screen.animation_play", text="Pause", icon='PAUSE')        else:            layout.operator("screen.animation_play", text="Play", icon='PLAY')        row = layout.row()        row.prop(scene, "wa_frame_exec", text="Frame change")        #row.label(text=f"Frame {scene.frame_current_final:6.1f}")        row.prop(scene, "wa_hide_viewport", text="Hide in VP")                layout.operator("wrap.clear_params", icon='CANCEL')           class WAControlPanel(bpy.types.Panel):    """User parameters to control animation"""    bl_label        = "User parameters"    bl_category     = "Wrap"    #bl_idname       = "SCENE_PT_layout"    bl_space_type   = 'VIEW_3D'    bl_region_type  = 'UI'    #bl_context      = "scene"    def draw(self, context):        layout = self.layout                ctl = get_control_object()        params = ui_param_list(ctl)                def draw_group(prms):            for pf in prms:                name  = pf[0]                fname = pf[1]                                if np.size(ctl[fname]) > 1:                    box = layout.box()                    box.label(text=name)                    col = box.column()                    col.prop(ctl,f'["{fname}"]',text = '')                                else:                    layout.prop(ctl,f'["{fname}"]', text=pf[0])                            prms = params.get("_main")        if prms is not None:            draw_group(prms)                for key,prms in params.items():            if key != "_main":                row = layout.row()                row.label(text=key)                draw_group(prms)def menu_func(self, context):    #self.layout.operator(AddMoebius.bl_idname, icon='MESH_ICOSPHERE')    passdef register():        bpy.types.Scene.wa_frame_exec    = bpy.props.BoolProperty(description="Execute at frame change")    bpy.types.Scene.wa_hide_viewport = bpy.props.BoolProperty(description="Hide in viewport when hiding render")        bpy.utils.register_class(ClearParamsOperator)    bpy.utils.register_class(SetupOperator)    bpy.utils.register_class(ExecOperator)    bpy.utils.register_class(WAMainPanel)    bpy.utils.register_class(WAControlPanel)       bpy.app.handlers.frame_change_pre.clear()    bpy.app.handlers.frame_change_pre.append(engine_handler)        # Enbsure control object is created    get_control_object()def unregister():    bpy.app.handlers.frame_change_pre.remove(engine_handler)        bpy.utils.unregister_class(WAMainPanel)    bpy.utils.unregister_class(WAControlPanel)    bpy.utils.unregister_class(ClearParamsOperator)    bpy.utils.unregister_class(SetupOperator)    bpy.utils.unregister_class(ExecOperator)if __name__ == "__main__":    register()    